import joblib
import numpy as np

# Load the trained model and label encoder
model = joblib.load('trained_model.pkl')
label_encoder = joblib.load('label_encoder.pkl')

# Function to make predictions and handle unmatched values
def predict_labels_and_handle_unmatched(values_list, indices_list):
    matched_list = []
    non_matched_list = []
    matched_indices = []
    non_matched_indices = []

    for value, index in zip(values_list, indices_list):
        try:
            # Try to convert value to integer (if possible)
            value = int(value)
        except ValueError:
            pass

        # Check if value is numeric after conversion
        if isinstance(value, (int, float)):
            # If numeric, assume it's a numerical feature (handle as needed)
            # Example: you might want to directly append the value or perform specific handling
            non_matched_list.append(value)
            non_matched_indices.append(index)
        else:
            # Encode label if it exists in the label_encoder classes
            if value in label_encoder.classes_:
                prediction = model.predict([label_encoder.transform([value])])[0]
                label = label_encoder.inverse_transform([prediction])[0]
                matched_list.append(label)
                matched_indices.append(index)
            else:
                non_matched_list.append(value)
                non_matched_indices.append(index)

    return matched_list, non_matched_list, matched_indices, non_matched_indices

# Example usage
values_list = ['USA', 155, 2546, 16545, 'vicjy', 'US']  # Replace with your list of values
indices_list = [0, 1, 2, 3, 4, 5]  # Replace with corresponding indices

matched_list, non_matched_list, matched_indices, non_matched_indices = predict_labels_and_handle_unmatched(values_list, indices_list)

# Print the results
print("Matched List:", matched_list)
print("Non-Matched List:", non_matched_list)
print("Matched Indices:", matched_indices)
print("Non-Matched Indices:", non_matched_indices)
